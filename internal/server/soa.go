package server

import (
	"banking-system/internal/database"
	"banking-system/internal/database/models"
	"banking-system/internal/database/repositories"
	"banking-system/internal/utils"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"time"
)

type SOAService struct {
	db database.Service
}


func NewSOAService(db database.Service) *SOAService {
	return &SOAService{db: db}
}

// GetSOA retrieves the SOA for a given user and with custom filters such as start date, end date, transaction type and item count.
// @Summary Get Statement of Account
// @Description Get a statement of account for a user with custom filters such as start date, end date, transaction type and item count.
// @Tags soa
// @Accept json
// @Produce json
// @Param request body models.GenerateSOACustomRequest true "Generate SOA Request" example({"start_date": "2024-03-01T00:00:00Z", "end_date": "2024-03-25T23:59:59Z", "item_count": 100, "transaction_type": "ALL"})
// @Success 200 {object} models.SOA
// @Failure 400 {object} models.Response
// @Failure 500 {object} models.Response
// @Router /soa/generate [post]
// @Security ApiKeyAuth
// @param Authorization header string true "Authorization" default(Bearer <Add access token here>)
func (s *SOAService) GetSOA(w http.ResponseWriter, r *http.Request, userID int) {
	var request models.GenerateSOACustomRequestUnformatted
	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		utils.WriteJSONError(w, http.StatusBadRequest, "Invalid request body: dates should be in RFC3339 format (e.g., '2006-01-02T15:04:05Z')", err)
		return
	}

	var finalRequest models.GenerateSOACustomRequest



	// Default start date to 30 days ago
	if request.StartDate == "" || request.StartDate == "0001-01-01 00:00:00 +0000 UTC" {
		finalRequest.StartDate = time.Now().AddDate(0, 0, -30)
	} else {
		var err error
		finalRequest.StartDate, err = time.Parse(time.RFC3339, request.StartDate)
		if err != nil {
			utils.WriteJSONError(w, http.StatusBadRequest, "Invalid start date", err)
			return
		}
	}

	// Default end date to today
	if request.EndDate == "" || request.EndDate == "0001-01-01 00:00:00 +0000 UTC" {
		finalRequest.EndDate = time.Now()
	} else {
		var err error
		finalRequest.EndDate, err = time.Parse(time.RFC3339, request.EndDate)
		if err != nil {
			utils.WriteJSONError(w, http.StatusBadRequest, "Invalid end date", err)
			return
		}
	}

	// Default item count to 50 if not specified
	if request.ItemCount <= 0 {
		finalRequest.ItemCount = 100
	}

	finalRequest.AccountID = request.AccountID
	finalRequest.Currency = request.Currency


	soaRepository := repositories.NewSOARepository(s.db)
	soa, err := soaRepository.GetSOA(userID, finalRequest)
	if err != nil {
		utils.WriteJSONError(w, http.StatusInternalServerError, "Failed to get SOA", err)
		return
	}

	// Save the PDF to the database
	err = soaRepository.SavePDF(soa.PDFUrl, userID)
	if err != nil {
		utils.WriteJSONError(w, http.StatusInternalServerError, "Failed to save PDF", err)
		return
	}

	utils.WriteJSONResponse(w, http.StatusOK, "SOA retrieved successfully", soa)
}

// GetGeneratedSOA retrieves all generated SOAs for a user
// @Summary Get All Generated SOAs
// @Description Get all statements of account generated by the user
// @Tags soa
// @Accept json
// @Produce json
// @Success 200 {object} models.Response
// @Failure 400 {object} models.Response
// @Failure 500 {object} models.Response
// @Router /soa/generated [get]
// @Security ApiKeyAuth
// @param Authorization header string true "Authorization" default(Bearer <Add access token here>)
func (s *SOAService) GetGeneratedSOA(w http.ResponseWriter, r *http.Request, userID int) {
	soaRepository := repositories.NewSOARepository(s.db)
	soas, err := soaRepository.GetGeneratedSOA(userID)
	if err != nil {
		utils.WriteJSONError(w, http.StatusInternalServerError, "Failed to get generated SOAs", err)
		return
	}

	utils.WriteJSONResponse(w, http.StatusOK, "Generated SOAs retrieved successfully", soas)
}


// DownloadSOA downloads a SOA by ID
// @Summary Download Statement of Account
// @Description Download a statement of account by ID
// @Tags soa
// @Accept json
// @Produce json
// @Param id query int true "SOA ID"
// @Success 200 {string} string "SOA downloaded successfully"
// @Failure 400 {object} models.Response
// @Failure 404 {object} models.Response
// @Failure 500 {object} models.Response
// @Router /soa/download [get]
// @Security ApiKeyAuth
// @param Authorization header string true "Authorization" default(Bearer <Add access token here>)
func (s *SOAService) DownloadSOA(w http.ResponseWriter, r *http.Request, soaID int) {
	soaRepository := repositories.NewSOARepository(s.db)
	soa, err := soaRepository.GetSOAByID(soaID)
	if err != nil {
		utils.WriteJSONError(w, http.StatusInternalServerError, "Failed to get SOA", err)
		return
	}

	if soa == nil {
		utils.WriteJSONError(w, http.StatusNotFound, "SOA not found", nil)
		return
	}

	filePath := soa.PDFUrl

	// Check if file exists before attempting to serve it
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		utils.WriteJSONError(w, http.StatusNotFound, "PDF file not found", err)
		return
	}

	// Set headers for file download
	w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%s", filepath.Base(soa.PDFUrl)))
	w.Header().Set("Content-Type", "application/pdf")

	// Serve the file
	http.ServeFile(w, r, filePath)
}

